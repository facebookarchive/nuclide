export type StatusCodeIdValue = string;
export type LineDiff = {
  oldStart: number,
  oldLines: number,
  newStart: number,
  newLines: number,
};
export type DiffInfo = {
  added: number,
  deleted: number,
  lineDiffs: Array<LineDiff>,
};
export type RevisionFileCopy = {
  from: string;
  to: string;
};
export type RevisionFileChanges = {
  all: Array<string>;
  added: Array<string>;
  deleted: Array<string>;
  copied: Array<RevisionFileCopy>;
  modified: Array<string>;
};

export class HgService {

  constructor(workingDirectory: string) {}

  /**
   * Section: File and Repository Status
   */

  /**
   * Shells out of the `hg status` to get the statuses of the paths. All paths
   * are presumed to be within the repo. (If any single path is not within the repo,
   * this method will return an empty map.)
   * @param options An Object with the following fields:
   *   * `hgStatusOption`: an HgStatusOption
   */
  fetchStatuses(
    filePaths: Array<NuclideUri>,
    options: ?any,
  ): Promise<Map<NuclideUri, StatusCodeIdValue>> {}

  /**
   * Observes one of more files has changed. Applies to all files except
   * .hgignore files. (See ::onHgIgnoreFileDidChange.)
   * @return A Observable which emits the changed file paths.
   */
  observeFilesDidChange(): Observable<Array<NuclideUri>> {}

  /**
   * Observes that a .hgignore file has changed.
   * @return A Observable which client could subscribe to.
   */
  observeHgIgnoreFileDidChange(): Observable<void> {}

  /**
   * Observes that a Mercurial event has occurred (e.g. histedit) that would
   * potentially invalidate any data cached from responses from this service.
   */
  observeHgRepoStateDidChange(): Observable<void> {}

  /**
   * Shells out to `hg diff` to retrieve line diff information for the path.
   * The path is presumed to be in the repo. If the `hg diff` call fails, this
   * method returns null.
   */
  fetchDiffInfo(filePath: NuclideUri): Promise<?DiffInfo> {}

  /**
   * Section: Bookmarks
   */

  /**
   * @return The name of the current bookmark.
   */
  fetchCurrentBookmark(): Promise<string> {}

  /**
   * Observes that the Mercurial bookmark has changed.
   */
  observeHgBookmarkDidChange(): Observable<void> {}

  /**
   * Section: Repository State at Specific Revisions
   */

  /**
   * @param filePath: The full path to the file of interest.
   * @param revision: An expression that hg can understand, specifying the
   * revision at which we want to see the file content.
   */
  fetchFileContentAtRevision(filePath: NuclideUri, revision: string): Promise<?string> {}

  fetchFilesChangedAtRevision(revision: string): Promise<?RevisionFileChanges> {}

  /**
   * @param revision The revision expression of a revision of interest. Note:
   * this can be the name of a bookmark, such as 'master'.
   * @return An expression for the common ancestor of the revision of interest and
   * the current Hg head.
   */
  fetchCommonAncestorOfHeadAndRevision(revision: string): Promise<string> {}

  /**
   * @param revisionFrom The revision expression of the "start" (older) revision.
   * @param revisionTo The revision expression of the "end" (newer) revision.
   * @return An array of revision numbers that are between revisionFrom and
   *   revisionTo, plus revisionFrom and revisionTo; and the values
   *   are all 'true'. "Between" means that revisionFrom is an ancestor of, and
   *   revisionTo is a descendant of.
   */
  fetchRevisionNumbersBetweenRevisions(
    revisionFrom: string,
    revisionTo: string
  ): Promise<Array<string>> {}

  /**
   * Gets the blame for the filePath at the current revision, including uncommitted changes
   * (but not unsaved changes).
   * @param filePath The file to get blame information for.
   * @return A Map that maps a line number (0-indexed) to the name that line blames to.
   *   The name is of the form: "Firstname Lastname <username@email.com> ChangeSetID".
   *   The Firstname Lastname may not appear sometimes.
   *   If no blame information is available, returns an empty Map.
   */
  getBlameAtHead(filePath: NuclideUri): Promise<Map<string, string>> {}

  /**
   * Gets the Differential Revision id (aka DXXXXXX) id for the specified changeSetId, if it exists.
   * Otherwise, returns null.
   */
  getDifferentialRevisionForChangeSetId(changeSetId: string): Promise<?string> {}

  /**
   * Get the output of the experimental smartlog extension from Mercurial:
   * https://bitbucket.org/facebook/hg-experimental/#markdown-header-smartlog.
   * @param ttyOutput If true, return the output as if stdout were attached to a tty.
   * @param concise true to run `hg smartlog`; false to run `hg sl`.
   * @return The output from running the command.
   */
  getSmartlog(ttyOutput: boolean, concise: boolean): Promise<string> {}

  /**
   * @param revision This could be a changeset ID, name of a bookmark, revision number, etc.
   * @param create Currently, this parameter is ignored.
   * @return whether the call to `hg checkout` succeeded.
   */
  checkout(revision: string, create: boolean): Promise<boolean> {}
}
